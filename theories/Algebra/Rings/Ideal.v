Require Import Basics Types.
Require Import Algebra.Rings.CRing.
Require Import Algebra.AbGroups.

Local Open Scope mc_add_scope.

(** In this file we define Ideals *)

(** An additive subgroup I of a ring R is an ideal when: *)
Class IsIdeal {R : CRing} (I : Subgroup R) :=
  isideal (r x : R) : I x -> I (r * x).

Record Ideal (R : CRing) := {
  ideal_subgroup : Subgroup R;
  ideal_isideal : IsIdeal ideal_subgroup;
}.

Coercion ideal_subgroup : Ideal >-> Subgroup.
Global Existing Instances ideal_isideal.

(** The zero ideal is an ideal *)
Global Instance isideal_trivial_subgroup (R : CRing)
  : IsIdeal (R:=R) trivial_subgroup.
Proof.
  hnf; cbn. intros r x p.
  refine (_ @ rng_mult_zero_r r).
  f_ap.
Defined.

(** Zero ideal *)
Definition ideal_zero (R : CRing) : Ideal R
  := Build_Ideal R _ (isideal_trivial_subgroup R).

(** The unit ideal is an ideal *)
Global Instance isideal_maximal_subgroup (R : CRing)
  : IsIdeal (R:=R) maximal_subgroup.
Proof.
  split.
Defined.

(** Unit ideal *)
Definition ideal_unit (R : CRing) : Ideal R
  := Build_Ideal R _ (isideal_maximal_subgroup R).

(** Intersections of underlying subgroups of ideals are again ideals *)
Global Instance isideal_subgroup_intersection (R : CRing) (I J : Ideal R)
  : IsIdeal (subgroup_intersection I J).
Proof.
  intros r x [a b]; split; by apply isideal.
Defined.

(** Intersection of ideals *)
Definition ideal_intersection (R : CRing) : Ideal R -> Ideal R -> Ideal R
  := fun I J => Build_Ideal R _ (isideal_subgroup_intersection R I J).

(** The subgroup product of ideals is again an ideal. *)
Global Instance isideal_subgroup_product (R : CRing) (I J : Ideal R)
  : IsIdeal (subgroup_product I J).
Proof.
  intros r.
  refine (subgroup_product_ind I J _  _ _ _ _).
  + intros x p.
    apply tr, sgt_in.
    left; by apply isideal.
  + intros x p.
    apply tr, sgt_in.
    right; by apply isideal.
  + apply tr, sgt_in.
    left; apply isideal.
    apply subgroup_unit.
  + intros x y p q IHp IHq.
    rewrite rng_dist_l.
    rewrite rng_mult_negate_r.
    by rapply subgroup_op_inverse.
Defined.

(** Sum of ideals *)
Definition ideal_sum (R : CRing) : Ideal R -> Ideal R -> Ideal R
  := fun I J => Build_Ideal R _ (isideal_subgroup_product R I J).

(** *** Ideal generated by a subset *)

(** It seems tempting to define ideals generated by a subset in terms of subgroups generated by a subset but this does not work. Ideals also have to be closed under left multiplciation by ring elements so they end up having more elements than the subgroup that gets generated. *)

(** Therefore we will do an analagous construction to the one done in Subgroup.v *)

(** Underlying type family of an ideal generated by subset *)
Inductive ideal_generated_type (R : CRing) (X : R -> Type) : R -> Type :=
(** The iddeal should contain all elements of the original family. *)
| igt_in (r : R) : X r -> ideal_generated_type R X r
(** It should contain zero. *)
| igt_zero : ideal_generated_type R X cring_zero
(** It should be closed under negation and addition. *)
| igt_add_neg (r s : R)
  : ideal_generated_type R X r
  -> ideal_generated_type R X s
  -> ideal_generated_type R X (r - s)
(** And finally, it should be closed under left multiplication. *)
| igt_mul (r s : R)
  : ideal_generated_type R X s
  -> ideal_generated_type R X (r * s)
.

Arguments ideal_generated_type {R} X r.
Arguments igt_in {R X r}.
Arguments igt_zero {R X}.
Arguments igt_add_neg {R X r s}.
Arguments igt_mul {R X r s}.

(** Again, as with subgroups we need to truncate this to make it a predicate. *)

(** Ideal generated by a subset *)
Definition ideal_generated {R : CRing} (X : R -> Type) : Ideal R.
Proof.
  snrapply Build_Ideal.
  { snrapply Build_Subgroup'.
    1: exact (fun x => merely (ideal_generated_type X x)).
    1: exact _.
    1: apply tr, igt_zero.
    intros x y p q; strip_truncations.
    by apply tr, igt_add_neg. }
  intros r x; apply Trunc_functor.
  apply igt_mul.
Defined.

(** *** Product of ideals *)

(** First we form the "naive" product of ideals { a * b | a ∈ I /\ b ∈ J } *)
(** Note that this is not an ideal, but we can fix this later. *)
Inductive ideal_product_naive_type (R : CRing) (I J : Ideal R) : R -> Type :=
| ipn_in : forall x y, I x -> J y -> ideal_product_naive_type R I J (x * y)
.

(** Now we can close this under addition to get the product ideal. *)

(** Product of ideals *)
Definition ideal_product (R : CRing) : Ideal R -> Ideal R -> Ideal R
  := fun I J => ideal_generated (ideal_product_naive_type R I J).

(** Products are a subset of the intersection *)
Lemma ideal_product_subset_intersection (R : CRing) (I J : Ideal R)
  : forall x, ideal_product R I J x -> ideal_intersection R I J x.
Proof.
  intros r p.
  strip_truncations.
  induction p as [r i | | r s p1 IHp1 p2 IHp2  | r s p IHp ].
  + destruct i.
    refine (_,_).
    1: rewrite commutativity.
    1,2: by apply isideal.
  + rapply subgroup_unit.
  + rapply subgroup_op.
    1: assumption.
    rewrite <- rng_mult_negate.
    by apply isideal.
  + by apply isideal.
Defined.

Definition ideal_kernel {R S : CRing} (f : CRingHomomorphism R S) : Ideal R.
Proof.
  snrapply Build_Ideal.
  1: exact (grp_kernel f).
  intros r x p; cbn in p.
  simpl.
  refine (rng_homo_mult _ _ _ @ _).
  refine (_ @ rng_mult_zero_r (f r)).
  f_ap.
Defined.

(** Properties of ideals *)

(** TODO: Maximal ideals *)
(** TODO: Principal ideal *)
(** TODO: Prime ideals *)
(** TODO: Radical ideals *)
(** TODO: Minimal ideals *)
(** TODO: Primary ideals *)

