(This was written in inadvertent parallel with Mike’s <a title="n-Category Café: Homotopy Type Theory VI" href="http://golem.ph.utexas.edu/category/2011/04/homotopy_type_theory_vi.html" target="_blank">latest post at the Café</a>, so there’s a little overlap — Mike’s discusses the homotopy-theoretic aspects more, this post the type-theoretic nitty-gritty.)

Higher inductive types have been mentioned now in <a title="n-Category Café: Homotopy Type Theory V" href="http://golem.ph.utexas.edu/category/2011/04/homotopy_type_theory_v.html" target="_blank">several</a> <a title="An Interval Type Implies Function Extensionality" href="http://homotopytypetheory.org/2011/04/04/an-interval-type-implies-function-extensionality/" target="_blank">other</a> <a title="Running Circles Around (In) Your Proof Assistant; or, Quotients that Compute" href="http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/" target="_blank">posts</a>, so it’s probably time to bring the full troupe out into the sunshine and show them off a bit.

If we’re aiming to do homotopy theory axiomatically within type theory — if our types are homotopy types — then in particular, we should hope to have types around representing the most fundamental spaces of topology: the circle, the interval, the 2-sphere… So, how should we construct these types? <!--more-->

Well, most types in dependent type theory (in CIC/Coq, all apart from function spaces) are constructed as <em>inductive types</em>, or the slightly more general <em>inductive families</em>. In Coq syntax, for instance, one defines the natural numbers as the type freely generated by an element <code>O</code> and an endomorphism <code>suc</code>:
<pre>Inductive (Nat : type) :=
  | O : Nat
  | suc : Nat -&gt; Nat.</pre>
From this definition, Coq automatically generates a <em>recursor</em> (aka an <em>eliminator</em>) for <code>nat</code> — an axiom giving the normal induction/recursion principles for $latex \mathbb{N}$, in a strong constructive form.

So it’s natural to ask if we can define the circle similarly, as the free type generated by a basepoint, and a path from that point to itself:
<pre>Inductive (Circle : Type) :=
  | base : Circle
  | loop : Paths base base.</pre>
Of course, Coq doesn’t accept this inductive definition — in normal inductive types, the constructors have to output elements of the type itself. So we have to axiomatise the type by hand. The type and its constructors are easy:
<pre>Axiom Circle : Type.

Axiom base : Circle.
Axiom loop : Paths base base.</pre>
What should the recursor look like? A map out of <code>Circle</code> into some other type should be specified simply by giving a point and a loop in that type; so as a first attempt, one might try:
<pre>Axiom circle_rec1 : forall (X : Type) (a : X) (l : Paths a a),
                       Circle -&gt; X.</pre>
together with computation axioms stating that <code>circle_rec1 X a l</code> sends <code>base</code> to <code>a</code> and <code>loop</code> to <code>l</code>.

This is fine as far as it goes, and lets one prove a few things; but it corresponds only to, say, simple recursion on $latex \mathbb{N}$. To prove anything much about the circle, one needs something corresponding to full induction on $latex \mathbb{N}$ — we need to be able to eliminate into a type dependent over <code>Circle</code> itself. So a second attempt might be:
<pre>
Axiom circle_rec2 : forall (P : Circle -&gt; Type)
                           (a : P base) (l : Paths a a),
                     forall (x : Circle), P x.</pre>
This was the first thing I tried originally… but a little thought shows it’s wrong! Why? Well, think topologically: we have a dependent type, so a <em>fibration</em> over the circle, for which we’re trying to give a section. A section doesn’t correspond to a loop in a fiber — which is what <code>circle_rec2</code> asked for. A section corresponds to a loop lying over the whole circle down below — equivalently, to a point <em>x</em>, and a path in the fiber, to <em>x</em>, from the result of transporting <em>x</em> once around the circle.

<a href="http://hottheory.files.wordpress.com/2011/04/img_3362-annotated.png"><img src="http://hottheory.files.wordpress.com/2011/04/img_3362-annotated.png" alt="Sections of a fibration over the circle" title="IMG_3362 annotated" width="640" height="425" class="alignnone size-full wp-image-459" /></a>

(My TikZ skills are sadly not quite up to drawing tori yet!) So the actual recursor we want is:
<pre>
Axiom circle_rec : forall (P : Circle -&gt; Type) (a : P base)
                          (l : Paths (transport loop a) a),
                   forall (x : Circle), P x.</pre>
where we’ve previously defined the auxiliary function <code>transport</code>, or looked it up in our libraries:
<pre> 
Lemma transport : forall {X : Type} {P : X -&gt; Type} {x x' : X}
                         (p : Paths x x'), (P x) -&gt; (P x').</pre>
This is now the correct recursor; so we just need to add the computation axioms, and then we’ve got the circle:
<pre>
Axiom circle_comp_base : forall (P : Circle -&gt; Type) (a : P base)
                                (l : Paths (transport loop a) a),
                         Paths (circle_rec P a l base) a.

Axiom circle_comp_loop : forall (P : Circle -&gt; Type) (a : P base)
                                (l : Paths (transport loop a) a),
         Paths (dependent_map_on_paths (circle_rec P a l) loop) l.</pre>
<hr />

So, now that we’ve got the circle, what can we prove about it, or with it? Well, some simple first exercises:
<ul>
	<li>The circle is contractible if and only if UIP holds — that is, exactly if all types are discrete. (This holds in for instance the set-theoretic model: when all paths are trivial, the unit type satisfies the axioms of <code>Circle</code>.)</li>
	<li>Assuming Univalence, there is no path in <code>Paths base base</code> from <code>loop</code> to <code>refl</code>.</li>
</ul>
Less simply, but more interestingly, Mike Shulman has managed to prove:
<ul>
	<li>Assuming Univalence, <code>Paths base base</code> is equivalent to <code>int</code>. In other words, $latex \Omega(S^1,x_0) \cong \pi_1(S^1,x_0) \cong \mathbb{Z}$.</li>
</ul>
So, this seems to be a reasonable proposal for how to axiomatise the circle type-theoretically. But beyond that, the same idea which we used for the circle also gives us lots of other homotopy-theoretic constructions, in quite convenient and (it seems) type-theoretically natural forms. So I’ll end for now with a quick parade of these, giving just their imagined definitions as Coq inductive types, the explicit types of their recursors, and some notes on what one can do with them.

And, of course, you can pull down the Coq code and play with them yourself — the definitions below appear in full in <a href="https://github.com/peterlefanulumsdaine/Homotopy/blob/master/Experimental/Menagerie.v" title="Coq file on GitHub" target="_blank"><code>Menagerie.v</code></a>, in my fork of Andrej’s <em>Homotopy</em> repository.
<pre>
Inductive Interval : Type :=
    | left : Interval
    | right : Interval
    | segment : Paths left right.

Axiom Interval_rect :
      forall {P : (Interval -&gt; Type)}
             (d_left : P left)
             (d_right : P right)
             (d_segment : (transport segment d_left) ~~&gt; d_right),
      forall x : Interval, P x.</pre>
Since one can prove that <code>Interval</code> is contractible, one might think there’s nothing interesting one can do with it. However, as <a title="An Interval Type Implies Function Extensionality" href="http://homotopytypetheory.org/2011/04/04/an-interval-type-implies-function-extensionality/" target="_blank">Mike showed</a> (and Chris Kapulkin noticed too), this implies functional extensionality, since it shows that paths are (in a weak sense) representable.

(That proof needs the computation rules to hold up to definitional equality, though; the version one can easily axiomatise in Coq, with the “computation” rules holding only up to homotopy, doesn’t imply this, since these axioms are all satisfied by the unit type. However, as <a title="Running Circles Around (In) Your Proof Assistant; or, Quotients that Compute" href="http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/" target="_blank">Dan’s last post</a> shows, there may be ways of getting around this.)
<pre>
Inductive Circle : Type :=
    | base : Circle
    | loop : Paths base base.

Axiom Circle_rect :
         forall {P : (Circle -&gt; Type)}
                (d_base : P base)
                (d_loop : (transport loop d_base) ~~&gt; d_base),
         forall x : Circle, P x.</pre>
As mentioned above, one can show that <code>Circle</code> is contractible if and only if UIP holds; and one can show that the loop space of <code>Circle</code> at <code>base</code> is equivalent to the integers.

<pre>
Inductive Circle' : Type :=
| east : Circle
| west : Circle'
| upper : Paths left right
| lower : Paths right left.

Axiom Circle'_rect :
forall {P : (Circle' -&gt; Type)}
(d_east : P east) (d_west : P west)
(d_upper : (transport upper d_east) ~~&gt; d_west)
(d_lower : (transport lower d_west) ~~&gt; d_east),
forall x : Circle', P x.
</pre>

An alternative presentation of the circle; proving this equivalent to <code>Circle</code> above is a nice exercise.
<pre>
Inductive Sphere2 : Type :=
    | base2 : Sphere
    | surf2 : Paths (@refl base2) (@refl base2).

Axiom Sphere2_rect :
         forall {P : (Sphere2 -&gt; Type)}
                (d_base2 : P base2)
                (d_surf2 : (transport (P := fun (p : base2 ~~&gt; base2) =&gt; ((transport p d_base2) ~~&gt; d_base2))
                            surf2 (idpath d_base2))
                            ~~&gt; (idpath d_base2)),
         forall x : Sphere2, P x.</pre>

<code>Sphere2</code> is contractible if and only if the principle “UIP-1” — that path spaces of path spaces are trivial — holds.

<pre>
Inductive Susp (X : Type) : Type :=
    | north : Susp X
    | south : Susp X
    | merid : X -&gt; Paths north south.

Axiom Susp_rect :
         forall {X : Type} {P : (Susp X) -&gt; Type}
                (d_north : P north)
                (d_south : P south)
                (d_merid : forall x : X, (transport (merid x) d_north) ~~&gt; d_south),
         forall x : Susp X, P x.</pre>
The <em>suspension</em> of a type. With this, one can define the spheres inductively, as a map from <code>nat</code> to <code>Type</code>.

<pre>
Inductive Cyl {X Y : Type} (f : X -&gt; Y) : Y -&gt; Type :=
    | cyl_base : forall y:Y, Cyl f y
    | cyl_top : forall x:X, Cyl f (f x)
    | cyl_seg : forall x:X, Paths (intop x) (inbase (f x)).


Axiom Cyl_rect : forall {X Y} {f:X-&gt;Y} {P : forall y, Cyl f y -&gt; Type},
                 forall (d_base : forall y:Y, P y (cyl_base y))
                        (d_top : forall x:X, P (f x) (cyl_top x))
                        (d_seg : forall x:X, (transport (cyl_seg x) (d_top x)) ~~&gt; (d_base (f x))),
                 forall (y : Y) (z : Cyl f y), P y z.</pre>

This gives the <em>mapping cylinder</em> of any map of types. Intuitively, this gives the factorisation of any map into a cofibration followed by a trivial fibration.

(Triviality is the fact that for each <code>y:Y</code>, the type <code>Cyl f y</code> is contractible; proving this in Coq is again a nice exercise.)

In fact one can make this intuition precise — if a type theory admits “mapping cylinder types”, then its types carry classes of maps behaving just like the fibrations, cofibrations, and weak equivalences of a model structure. The fibrations are (generated by) dependent families of types; trivial fibrations, families of contractible types; cofibrations, constructos of (possibly higher) inductive types; trivial cofibrations, constructors of inductive types with a single constructor; and weak equivalences are exactly maps which are equivalences as defined in the type theory. (So the trivial cofibrations and fibrations of this “pre-model-structure” are exactly <a title="Gambino, Garner: The identity type weak factorisation system" href="http://arxiv.org/abs/0803.4349" target="_blank">the Gambino-Garner weak factorisation system</a>.)

<pre>
Inductive isInhab (X:Type) : Type :=
    | proj : X -&gt; isInhab X
    | contr : forall (y y' : isInhab X), Paths y y'.

Axiom isInhab_rect : forall {X:Type},
         forall {P : isInhab X -&gt; Type}
                (d_proj : forall x:X, P (proj x))
                (d_contr : forall (z z' : isInhab X) (w : P z) (w' : P z'), (transport (contr z z') w) ~~&gt; w'),
         forall z : isInhab X, P z.</pre>

This could be also described as $latex \text{tr}_{-1}$, or $latex \pi_{-1}$: it gives a reflection from types into homotopy-propositions, squashing any type down to one which is contractible if it’s inhabited.

This is our first example that is “properly recursive”, with a constructor taking inputs from the inductive type itself.

<pre>
Inductive tr0 (X:Type) : Type :=
    | incl : X -&gt; tr0 X
    | contr : forall (l : Circle -&gt; X),
                 Paths (refl (l base)) (cong l loop)
</pre>

Similarly, with proper recursion, we can construct the 0-truncation, $latex \mathrm{tr}_0$, aka $latex \pi_0$, of any type; and this idea extends to give higher truncations as well. Here I’ve used a constructor whose arity is <code>Circle</code>; alternatively, one could also relax the restrictions on <em>input</em> types of constructors, to allow them to take paths directly as inputs:
<pre>
Inductive tr0 (X:Type) : Type :=
    | incl : X -&gt; tr0 X
    | contr : forall (z : tr0 X) (p : Paths z z), Paths p (refl z)
</pre>

<hr />

(A little bit of attribution: the basic idea of higher inductive types came from questions that were a lot in the air at Oberwolfach, and most immediately from discussions on the hike between Mike Shulman, Andrej Bauer, Michael Warren and myself. Since then, we and Chris Kapulkin have been playing with them further, and Dan Licata and Steve Awodey have independently been working on some closely related ideas, which I believe Dan is planning to post about soon…)